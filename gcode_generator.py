"""
G-code Generator
Converts STL files to G-code for 3D printing
"""
import numpy as np
from stl import mesh
from typing import Dict, Any, List, Tuple
import math
from collections import defaultdict


class GCodeGenerator:
    """Generator for creating G-code from STL files"""
    
    def __init__(self, settings: Dict[str, Any]):
        """
        Initialize generator with settings
        
        Args:
            settings: Dictionary containing printer and printing settings
        """
        self.settings = settings
        self.current_x = 0.0
        self.current_y = 0.0
        self.current_z = 0.0
        self.current_e = 0.0
        self.layer_height = settings.get('layer', {}).get('height', 0.2)
        self.first_layer_height = settings.get('layer', {}).get('first_height', 0.2)
        self.nozzle_diameter = settings.get('printer', {}).get('nozzle_diameter', 0.4)
        self.extrusion_width = settings.get('extrusion', {}).get('perimeter', 0.45)
        self.filament_diameter = 1.75  # Standard 1.75mm filament
        # Initialize offsets
        self.offset_x = 0.0
        self.offset_y = 0.0
        self.min_z = 0.0
        # Infill settings
        self.infill_pattern = settings.get('infill', {}).get('pattern', 'rectilinear')
        self.infill_density = settings.get('infill', {}).get('density', 20.0)  # Percentage
        self.infill_angles = settings.get('infill', {}).get('angles', [45, 135])  # Default angles for alternating layers
        
    def generate_from_stl(self, stl_path: str, output_path: str = None) -> str:
        """
        Generate G-code from STL file
        
        Args:
            stl_path: Path to STL file
            output_path: Optional path to save G-code file
            
        Returns:
            G-code content as string
        """
        # Load STL mesh
        stl_mesh = mesh.Mesh.from_file(stl_path)
        
        # Generate G-code
        gcode_lines = []
        
        # Header
        gcode_lines.extend(self._generate_header())
        
        # Initial setup
        gcode_lines.extend(self._generate_initial_setup(stl_mesh))
        
        # Slice mesh into layers
        layers = self._slice_mesh(stl_mesh)
        
        if not layers:
            # If no layers, return empty G-code with error message
            gcode_lines.append('; ERROR: Could not slice mesh into layers')
            gcode_lines.extend(self._generate_footer())
            gcode_content = '\n'.join(gcode_lines)
            if output_path:
                with open(output_path, 'w') as f:
                    f.write(gcode_content)
            return gcode_content
        
        # Generate G-code for each layer
        for layer_num, layer_data in enumerate(layers):
            gcode_lines.extend(self._generate_layer(layer_num, layer_data))
        
        # Footer
        gcode_lines.extend(self._generate_footer())
        
        gcode_content = '\n'.join(gcode_lines)
        
        # Save if output path provided
        if output_path:
            with open(output_path, 'w') as f:
                f.write(gcode_content)
        
        return gcode_content
    
    def _generate_header(self) -> List[str]:
        """Generate G-code header with settings"""
        lines = [
            '; Generated by Text-2D-STL G-code Generator',
            ';',
            '; Printer Settings:',
        ]
        
        printer = self.settings.get('printer', {})
        if 'nozzle_diameter' in printer:
            lines.append(f'; Nozzle diameter: {printer["nozzle_diameter"]}mm')
        
        lines.extend([
            ';',
            '; Printing Settings:',
        ])
        
        temps = self.settings.get('temperatures', {})
        if 'bed_temperature' in temps:
            lines.append(f'; Bed temperature: {temps["bed_temperature"]}°C')
        if 'extruder_temperature' in temps:
            lines.append(f'; Extruder temperature: {temps["extruder_temperature"]}°C')
        
        layer = self.settings.get('layer', {})
        if 'height' in layer:
            lines.append(f'; Layer height: {layer["height"]}mm')
        
        lines.extend([
            ';',
            'G21 ; Set units to millimeters',
            'G90 ; Use absolute coordinates',
            'M82 ; Set extruder to absolute mode',
            'M107 ; Turn off fan',
        ])
        
        return lines
    
    def _generate_initial_setup(self, stl_mesh) -> List[str]:
        """Generate initial setup commands"""
        lines = []
        
        # Home axes
        lines.append('G28 ; Home all axes')
        
        # Set temperatures - use first layer temps if available, otherwise regular temps
        temps = self.settings.get('temperatures', {})
        bed_temp = temps.get('first_layer_bed_temperature') or temps.get('bed_temperature', 60)
        extruder_temp = temps.get('first_layer_temperature') or temps.get('extruder_temperature', 210)
        
        lines.append(f'M140 S{bed_temp} ; Set bed temperature')
        lines.append(f'M104 S{extruder_temp} ; Set extruder temperature')
        
        # Wait for temperatures
        lines.append('M190 ; Wait for bed temperature')
        lines.append('M109 ; Wait for extruder temperature')
        
        # Reset extruder
        lines.append('G92 E0 ; Reset extruder')
        self.current_e = 0.0
        
        # Get mesh bounds to center on bed
        min_z = float('inf')
        max_z = float('-inf')
        min_x = float('inf')
        max_x = float('-inf')
        min_y = float('inf')
        max_y = float('-inf')
        
        for vector in stl_mesh.vectors:
            for v in vector:
                min_z = min(min_z, v[2])
                max_z = max(max_z, v[2])
                min_x = min(min_x, v[0])
                max_x = max(max_x, v[0])
                min_y = min(min_y, v[1])
                max_y = max(max_y, v[1])
        
        # Center the model on bed (assuming 220x220 bed)
        bed_size = 220
        model_width = max_x - min_x
        model_depth = max_y - min_y
        offset_x = (bed_size - model_width) / 2 - min_x
        offset_y = (bed_size - model_depth) / 2 - min_y
        
        # Store offset for later use
        self.offset_x = offset_x
        self.offset_y = offset_y
        self.min_z = min_z
        
        # Move to first layer Z position
        # For 3D printing, Z=0 is the bed surface
        # If mesh starts below bed (negative Z), adjust to start at bed
        # Otherwise, start at first_layer_height above the mesh bottom
        if min_z < 0:
            # Mesh extends below bed - start at first_layer_height above bed
            first_layer_z = self.first_layer_height
        else:
            # Mesh starts at or above bed - start at first_layer_height above mesh bottom
            first_layer_z = min_z + self.first_layer_height
        
        # Ensure first layer is at least at first_layer_height above bed (Z=0)
        if first_layer_z < self.first_layer_height:
            first_layer_z = self.first_layer_height
        
        lines.append(f'G1 Z{first_layer_z:.3f} F3000 ; Move to first layer height (Z={first_layer_z:.3f}mm)')
        self.current_z = first_layer_z
        
        # Set initial speeds
        speeds = self.settings.get('speeds', {})
        first_layer_speed = speeds.get('first_layer', 20) * 60  # Convert mm/s to mm/min
        lines.append(f'G1 F{first_layer_speed:.0f} ; Set initial speed')
        
        return lines
    
    def _slice_mesh(self, stl_mesh) -> List[Dict]:
        """
        Slice STL mesh into layers using triangle-plane intersection
        
        Args:
            stl_mesh: STL mesh object
            
        Returns:
            List of layer data dictionaries
        """
        # Get mesh Z bounds
        min_z = float('inf')
        max_z = float('-inf')
        
        for vector in stl_mesh.vectors:
            for v in vector:
                min_z = min(min_z, v[2])
                max_z = max(max_z, v[2])
        
        if min_z == float('inf') or max_z == float('-inf'):
            return []
        
        # Calculate number of layers
        total_height = max_z - min_z
        if total_height <= 0:
            return []
        
        # Calculate layer Z positions
        # Start from the bottom of the mesh (min_z) and add first layer height
        # Then continue with regular layer height for subsequent layers
        layers = []
        
        # First layer starts at min_z + first_layer_height
        # But if min_z is already 0 or negative, we want to ensure we start at a positive Z
        # For 3D printing, Z=0 is typically the bed surface
        if min_z < 0:
            # If mesh extends below bed, adjust
            z_offset = -min_z
            min_z = 0
            max_z = max_z + z_offset
        
        current_z = min_z + self.first_layer_height
        layer_num = 0
        
        # Store first layer contours to use for all layers (for simple extrusions)
        first_layer_contours = None
        
        while current_z <= max_z + 0.01:  # Small tolerance
            # Get contours at this Z level
            contours = self._get_contours_at_z(stl_mesh, current_z)
            
            # If no contours found, try using first layer contours (for simple vertical extrusions)
            if not contours and first_layer_contours:
                contours = first_layer_contours
            
            # Store first layer contours
            if layer_num == 0 and contours:
                first_layer_contours = contours
            
            # Always add layer, even if no contours (will skip in generation)
            if contours or layer_num == 0:
                layers.append({
                    'z': current_z,
                    'contours': contours if contours else (first_layer_contours if first_layer_contours else []),
                    'layer_num': layer_num
                })
            
            # Move to next layer
            if layer_num == 0:
                # After first layer, use regular layer height
                current_z = min_z + self.first_layer_height + self.layer_height
            else:
                current_z += self.layer_height
            layer_num += 1
        
        return layers
    
    def _get_contours_at_z(self, stl_mesh, z_level: float, tolerance: float = 0.01) -> List[List[Tuple[float, float]]]:
        """
        Get 2D contours at a specific Z level by intersecting triangles with the plane
        
        Args:
            stl_mesh: STL mesh object
            z_level: Z coordinate to slice at
            tolerance: Tolerance for Z level matching
            
        Returns:
            List of contours (each contour is a list of (x, y) tuples)
        """
        segments = []
        
        # Find all line segments where triangles intersect the Z plane
        for triangle in stl_mesh.vectors:
            # Get triangle vertices
            v0, v1, v2 = triangle[0], triangle[1], triangle[2]
            
            # Check which vertices are above, on, or below the plane
            z0, z1, z2 = v0[2], v1[2], v2[2]
            
            # Find intersections
            intersections = []
            
            # Edge v0-v1
            if (z0 <= z_level <= z1) or (z1 <= z_level <= z0):
                if abs(z1 - z0) > 1e-6:
                    t = (z_level - z0) / (z1 - z0)
                    x = v0[0] + t * (v1[0] - v0[0])
                    y = v0[1] + t * (v1[1] - v0[1])
                    intersections.append((x, y))
            
            # Edge v1-v2
            if (z1 <= z_level <= z2) or (z2 <= z_level <= z1):
                if abs(z2 - z1) > 1e-6:
                    t = (z_level - z1) / (z2 - z1)
                    x = v1[0] + t * (v2[0] - v1[0])
                    y = v1[1] + t * (v2[1] - v1[1])
                    intersections.append((x, y))
            
            # Edge v2-v0
            if (z2 <= z_level <= z0) or (z0 <= z_level <= z2):
                if abs(z0 - z2) > 1e-6:
                    t = (z_level - z2) / (z0 - z2)
                    x = v2[0] + t * (v0[0] - v2[0])
                    y = v2[1] + t * (v0[1] - v2[1])
                    intersections.append((x, y))
            
            # Add segment if we have two intersection points
            if len(intersections) == 2:
                segments.append((intersections[0], intersections[1]))
        
        if not segments:
            return []
        
        # Connect segments into closed contours
        contours = self._connect_segments_to_contours(segments)
        
        return contours
    
    def _connect_segments_to_contours(self, segments: List[Tuple[Tuple[float, float], Tuple[float, float]]]) -> List[List[Tuple[float, float]]]:
        """
        Connect line segments into closed contours
        
        Args:
            segments: List of line segments ((x1, y1), (x2, y2))
            
        Returns:
            List of closed contours
        """
        if not segments:
            return []
        
        contours = []
        used_segments = set()
        tolerance = 0.01
        
        def points_equal(p1, p2):
            return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) < tolerance
        
        for i, seg in enumerate(segments):
            if i in used_segments:
                continue
            
            # Start a new contour
            contour = []
            current_seg = seg
            used_segments.add(i)
            
            # Start with first point
            start_point = current_seg[0]
            contour.append(start_point)
            current_point = current_seg[1]
            
            # Try to find connected segments
            found = True
            while found:
                contour.append(current_point)
                found = False
                
                # Look for a segment that connects to current_point
                for j, next_seg in enumerate(segments):
                    if j in used_segments:
                        continue
                    
                    if points_equal(current_point, next_seg[0]):
                        current_point = next_seg[1]
                        used_segments.add(j)
                        found = True
                        break
                    elif points_equal(current_point, next_seg[1]):
                        current_point = next_seg[0]
                        used_segments.add(j)
                        found = True
                        break
            
            # Check if contour is closed
            if len(contour) > 2 and points_equal(contour[0], contour[-1]):
                contours.append(contour[:-1])  # Remove duplicate last point
            elif len(contour) > 2:
                # Try to close the contour
                if points_equal(contour[0], contour[-1]):
                    contours.append(contour[:-1])
                else:
                    # Add first point to close
                    contours.append(contour + [contour[0]])
        
        return contours
    
    def _generate_layer(self, layer_num: int, layer_data: Dict) -> List[str]:
        """Generate G-code for a single layer with perimeters and infill"""
        lines = []
        
        z_pos = layer_data['z']
        
        # Ensure Z position is valid (at least first_layer_height for first layer)
        if layer_num == 0 and z_pos < self.first_layer_height:
            z_pos = self.first_layer_height
        
        # Move to layer Z position (always set Z for first layer, then only if changed)
        if layer_num == 0 or abs(self.current_z - z_pos) > 0.01:
            lines.append(f'; LAYER:{layer_num}')
            lines.append(f'G1 Z{z_pos:.3f} F3000 ; Move to layer {layer_num} (Z={z_pos:.3f}mm)')
            self.current_z = z_pos
        
        # Get speeds for this layer
        speeds = self.settings.get('speeds', {})
        if layer_num == 0:
            perimeter_speed = speeds.get('first_layer', 20) * 60
            infill_speed = speeds.get('first_layer', 20) * 60
        else:
            perimeter_speed = speeds.get('perimeter', 60) * 60
            infill_speed = speeds.get('infill', 80) * 60
        
        # Generate paths for contours
        contours = layer_data.get('contours', [])
        if not contours:
            return lines
        
        # Sort contours by area (largest first) - outer contours first
        contours_with_area = []
        for contour in contours:
            if len(contour) < 3:
                continue
            # Calculate area using shoelace formula
            area = 0
            for i in range(len(contour)):
                j = (i + 1) % len(contour)
                area += contour[i][0] * contour[j][1]
                area -= contour[j][0] * contour[i][1]
            area = abs(area) / 2
            contours_with_area.append((area, contour))
        
        contours_with_area.sort(reverse=True, key=lambda x: x[0])
        
        # Get outer contour (largest area) for infill generation
        outer_contour = None
        if contours_with_area:
            outer_contour = contours_with_area[0][1]
        
        # Generate perimeters (outlines) - typically 2-3 perimeters
        num_perimeters = 2
        for perimeter_num in range(num_perimeters):
            for area, contour in contours_with_area:
                # Apply offset to center on bed
                offset_contour = [(x + self.offset_x, y + self.offset_y) for x, y in contour]
                lines.extend(self._generate_contour_path(offset_contour, perimeter_speed, layer_num == 0, is_perimeter=True))
        
        # Generate infill if density > 0
        if self.infill_density > 0 and outer_contour:
            # Apply offset to outer contour
            offset_outer = [(x + self.offset_x, y + self.offset_y) for x, y in outer_contour]
            infill_lines = self._generate_infill(offset_outer, infill_speed, layer_num == 0, layer_num)
            if infill_lines:
                lines.extend(infill_lines)
        
        return lines
    
    def _generate_contour_path(self, contour: List[Tuple[float, float]], speed: float, is_first_layer: bool = False, is_perimeter: bool = True) -> List[str]:
        """Generate G-code path for a contour"""
        lines = []
        
        if len(contour) < 3:
            return lines
        
        # Use appropriate extrusion width
        if is_first_layer:
            extrusion_width = self.settings.get('extrusion', {}).get('first_layer', self.extrusion_width)
        elif is_perimeter:
            extrusion_width = self.settings.get('extrusion', {}).get('external_perimeter', self.extrusion_width)
        else:
            extrusion_width = self.settings.get('extrusion', {}).get('infill', self.extrusion_width)
        
        # Move to first point (rapid move, no extrusion)
        first_x, first_y = contour[0]
        lines.append(f'G1 X{first_x:.3f} Y{first_y:.3f} F{speed:.0f} ; Move to start')
        self.current_x = first_x
        self.current_y = first_y
        
        # Draw contour with extrusion
        for x, y in contour[1:]:
            e_amount = self._calculate_extrusion(self.current_x, self.current_y, x, y, extrusion_width)
            self.current_e += e_amount
            lines.append(f'G1 X{x:.3f} Y{y:.3f} E{self.current_e:.5f} F{speed:.0f}')
            self.current_x = x
            self.current_y = y
        
        # Close contour
        e_amount = self._calculate_extrusion(self.current_x, self.current_y, first_x, first_y, extrusion_width)
        self.current_e += e_amount
        lines.append(f'G1 X{first_x:.3f} Y{first_y:.3f} E{self.current_e:.5f} F{speed:.0f} ; Close contour')
        
        return lines
    
    def _generate_infill(self, outer_contour: List[Tuple[float, float]], speed: float, is_first_layer: bool = False, layer_num: int = 0) -> List[str]:
        """
        Generate infill pattern inside the outer contour
        
        Args:
            outer_contour: Outer contour of the layer
            speed: Printing speed in mm/min
            is_first_layer: Whether this is the first layer
            
        Returns:
            List of G-code lines for infill
        """
        if self.infill_density <= 0:
            return []
        
        lines = []
        
        # Get infill extrusion width
        if is_first_layer:
            extrusion_width = self.settings.get('extrusion', {}).get('first_layer', self.extrusion_width)
        else:
            extrusion_width = self.settings.get('extrusion', {}).get('infill', self.extrusion_width)
        
        # Get bounding box of contour
        if not outer_contour:
            return []
        
        min_x = min(p[0] for p in outer_contour)
        max_x = max(p[0] for p in outer_contour)
        min_y = min(p[1] for p in outer_contour)
        max_y = max(p[1] for p in outer_contour)
        
        # Calculate infill spacing based on density (PrusaSlicer-style)
        # Density is percentage: 0% = no infill, 100% = solid
        # For rectilinear/grid: spacing = extrusion_width / (density / 100)
        # PrusaSlicer uses: spacing = line_width / (fill_density / 100)
        if self.infill_density >= 100:
            spacing = extrusion_width  # Solid infill (lines touch)
        elif self.infill_density <= 0:
            return []  # No infill
        else:
            # Calculate spacing: higher density = smaller spacing
            # For 20% density: spacing = width / 0.2 = 5 * width
            spacing = extrusion_width / (self.infill_density / 100.0)
        
        # Generate infill based on pattern (PrusaSlicer-style)
        pattern_lower = self.infill_pattern.lower()
        if pattern_lower == 'rectilinear':
            infill_lines = self._generate_rectilinear_infill(
                outer_contour, min_x, max_x, min_y, max_y, spacing, speed, extrusion_width, layer_num
            )
        elif pattern_lower == 'grid':
            infill_lines = self._generate_grid_infill(
                outer_contour, min_x, max_x, min_y, max_y, spacing, speed, extrusion_width, layer_num
            )
        elif pattern_lower == 'triangles' or pattern_lower == 'triangle':
            infill_lines = self._generate_triangles_infill(
                outer_contour, min_x, max_x, min_y, max_y, spacing, speed, extrusion_width, layer_num
            )
        elif pattern_lower == 'honeycomb':
            infill_lines = self._generate_honeycomb_infill(
                outer_contour, min_x, max_x, min_y, max_y, spacing, speed, extrusion_width, layer_num
            )
        else:
            # Default to rectilinear
            infill_lines = self._generate_rectilinear_infill(
                outer_contour, min_x, max_x, min_y, max_y, spacing, speed, extrusion_width, layer_num
            )
        
        lines.extend(infill_lines)
        return lines
    
    def _generate_rectilinear_infill(self, contour: List[Tuple[float, float]], 
                                   min_x: float, max_x: float, min_y: float, max_y: float,
                                   spacing: float, speed: float, extrusion_width: float, layer_num: int = 0) -> List[str]:
        """
        Generate rectilinear infill pattern using angles from settings
        PrusaSlicer-style: alternates between angles (typically 45° and 135°)
        """
        lines = []
        
        # Select angle for this layer (alternate between available angles)
        if not self.infill_angles:
            self.infill_angles = [45, 135]  # Default
        
        angle_idx = layer_num % len(self.infill_angles)
        angle_deg = self.infill_angles[angle_idx]
        angle_rad = math.radians(angle_deg)
        
        # Calculate line spacing perpendicular to the angle
        # For angled lines, spacing needs to be adjusted
        perp_spacing = spacing / abs(math.cos(angle_rad)) if abs(math.cos(angle_rad)) > 0.001 else spacing / abs(math.sin(angle_rad))
        
        # Calculate bounding box diagonal for line generation
        center_x = (min_x + max_x) / 2
        center_y = (min_y + max_y) / 2
        diag_length = math.sqrt((max_x - min_x)**2 + (max_y - min_y)**2)
        
        # Generate lines at the specified angle
        # Create lines perpendicular to the angle direction
        perp_angle = angle_deg + 90
        perp_angle_rad = math.radians(perp_angle)
        
        # Calculate how many lines we need
        num_lines = int(diag_length / perp_spacing) + 2
        
        for i in range(-num_lines, num_lines + 1):
            # Calculate line offset
            offset = i * perp_spacing
            
            # Create a line at the specified angle passing through the center + offset
            # Line equation: y = tan(angle) * (x - center_x) + center_y + offset_perp
            tan_angle = math.tan(angle_rad) if abs(math.cos(angle_rad)) > 0.001 else float('inf')
            
            # Find intersections with bounding box
            intersections = []
            
            # Check intersection with each bounding box edge
            # Top edge (y = max_y)
            if abs(tan_angle) < 1000:  # Not vertical
                x_at_top = center_x + (max_y - center_y - offset * math.cos(perp_angle_rad)) / tan_angle
                if min_x <= x_at_top <= max_x:
                    intersections.append((x_at_top, max_y))
            
            # Bottom edge (y = min_y)
            if abs(tan_angle) < 1000:
                x_at_bottom = center_x + (min_y - center_y - offset * math.cos(perp_angle_rad)) / tan_angle
                if min_x <= x_at_bottom <= max_x:
                    intersections.append((x_at_bottom, min_y))
            
            # Left edge (x = min_x)
            if abs(tan_angle) < 1000:
                y_at_left = center_y + tan_angle * (min_x - center_x) + offset * math.cos(perp_angle_rad)
                if min_y <= y_at_left <= max_y:
                    intersections.append((min_x, y_at_left))
            
            # Right edge (x = max_x)
            if abs(tan_angle) < 1000:
                y_at_right = center_y + tan_angle * (max_x - center_x) + offset * math.cos(perp_angle_rad)
                if min_y <= y_at_right <= max_y:
                    intersections.append((max_x, y_at_right))
            
            # If vertical line (angle ≈ 90° or 270°)
            if abs(tan_angle) >= 1000:
                x_line = center_x + offset * math.cos(perp_angle_rad)
                if min_x <= x_line <= max_x:
                    intersections = [(x_line, min_y), (x_line, max_y)]
            
            # Remove duplicates and find actual intersections with contour
            if len(intersections) >= 2:
                # Use the two furthest points as line endpoints
                if len(intersections) > 2:
                    # Find the two points that form the longest line through the bounding box
                    max_dist = 0
                    best_pair = (intersections[0], intersections[1])
                    for i1, p1 in enumerate(intersections):
                        for i2, p2 in enumerate(intersections[i1+1:], i1+1):
                            dist = math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
                            if dist > max_dist:
                                max_dist = dist
                                best_pair = (p1, p2)
                    intersections = list(best_pair)
                
                # Find actual intersections with contour
                p1, p2 = intersections[0], intersections[1]
                contour_intersections = self._line_contour_intersections(contour, p1[0], p1[1], p2[0], p2[1])
                
                if len(contour_intersections) >= 2:
                    # Sort by distance from first point
                    def dist_from_p1(p):
                        return math.sqrt((p[0] - p1[0])**2 + (p[1] - p1[1])**2)
                    contour_intersections.sort(key=dist_from_p1)
                    
                    # Draw lines between pairs
                    for j in range(0, len(contour_intersections) - 1, 2):
                        if j + 1 < len(contour_intersections):
                            x1, y1 = contour_intersections[j]
                            x2, y2 = contour_intersections[j + 1]
                            # Move to start
                            lines.append(f'G1 X{x1:.3f} Y{y1:.3f} F{speed:.0f} ; Infill move')
                            self.current_x, self.current_y = x1, y1
                            # Draw line
                            e_amount = self._calculate_extrusion(x1, y1, x2, y2, extrusion_width)
                            self.current_e += e_amount
                            lines.append(f'G1 X{x2:.3f} Y{y2:.3f} E{self.current_e:.5f} F{speed:.0f} ; Infill')
                            self.current_x, self.current_y = x2, y2
        
        return lines
    
    def _generate_grid_infill(self, contour: List[Tuple[float, float]], 
                             min_x: float, max_x: float, min_y: float, max_y: float,
                             spacing: float, speed: float, extrusion_width: float, layer_num: int = 0) -> List[str]:
        """
        Generate grid infill pattern (both directions in same layer, like PrusaSlicer)
        Uses 0° and 90° angles
        """
        lines = []
        
        # Generate horizontal lines (0°)
        y = min_y + spacing
        while y < max_y:
            intersections = self._line_contour_intersections(contour, min_x, y, max_x, y)
            if len(intersections) >= 2:
                intersections.sort(key=lambda p: p[0])
                for i in range(0, len(intersections) - 1, 2):
                    if i + 1 < len(intersections):
                        x1, y1 = intersections[i]
                        x2, y2 = intersections[i + 1]
                        lines.append(f'G1 X{x1:.3f} Y{y1:.3f} F{speed:.0f} ; Infill move')
                        self.current_x, self.current_y = x1, y1
                        e_amount = self._calculate_extrusion(x1, y1, x2, y2, extrusion_width)
                        self.current_e += e_amount
                        lines.append(f'G1 X{x2:.3f} Y{y2:.3f} E{self.current_e:.5f} F{speed:.0f} ; Infill')
                        self.current_x, self.current_y = x2, y2
            y += spacing
        
        # Generate vertical lines (90°)
        x = min_x + spacing
        while x < max_x:
            intersections = self._line_contour_intersections(contour, x, min_y, x, max_y)
            if len(intersections) >= 2:
                intersections.sort(key=lambda p: p[1])
                for i in range(0, len(intersections) - 1, 2):
                    if i + 1 < len(intersections):
                        x1, y1 = intersections[i]
                        x2, y2 = intersections[i + 1]
                        lines.append(f'G1 X{x1:.3f} Y{y1:.3f} F{speed:.0f} ; Infill move')
                        self.current_x, self.current_y = x1, y1
                        e_amount = self._calculate_extrusion(x1, y1, x2, y2, extrusion_width)
                        self.current_e += e_amount
                        lines.append(f'G1 X{x2:.3f} Y{y2:.3f} E{self.current_e:.5f} F{speed:.0f} ; Infill')
                        self.current_x, self.current_y = x2, y2
            x += spacing
        
        return lines
    
    def _generate_triangles_infill(self, contour: List[Tuple[float, float]], 
                                   min_x: float, max_x: float, min_y: float, max_y: float,
                                   spacing: float, speed: float, extrusion_width: float, layer_num: int = 0) -> List[str]:
        """
        Generate triangles infill pattern (three directions: 0°, 60°, 120°)
        PrusaSlicer-style: alternates which set of angles to use per layer
        """
        lines = []
        
        # Use different angle sets based on layer
        if layer_num % 2 == 0:
            angles = [0, 60, 120]
        else:
            angles = [30, 90, 150]  # Offset by 30° for alternating layers
        
        # Generate lines for each angle
        for angle_deg in angles:
            angle_rad = math.radians(angle_deg)
            tan_angle = math.tan(angle_rad) if abs(math.cos(angle_rad)) > 0.001 else float('inf')
            
            center_x = (min_x + max_x) / 2
            center_y = (min_y + max_y) / 2
            diag_length = math.sqrt((max_x - min_x)**2 + (max_y - min_y)**2)
            perp_spacing = spacing / abs(math.cos(angle_rad)) if abs(math.cos(angle_rad)) > 0.001 else spacing / abs(math.sin(angle_rad))
            num_lines = int(diag_length / perp_spacing) + 2
            
            for i in range(-num_lines, num_lines + 1):
                offset = i * perp_spacing
                perp_angle = angle_deg + 90
                perp_angle_rad = math.radians(perp_angle)
                
                intersections = []
                if abs(tan_angle) < 1000:
                    # Check bounding box intersections
                    x_at_top = center_x + (max_y - center_y - offset * math.cos(perp_angle_rad)) / tan_angle
                    if min_x <= x_at_top <= max_x:
                        intersections.append((x_at_top, max_y))
                    x_at_bottom = center_x + (min_y - center_y - offset * math.cos(perp_angle_rad)) / tan_angle
                    if min_x <= x_at_bottom <= max_x:
                        intersections.append((x_at_bottom, min_y))
                    y_at_left = center_y + tan_angle * (min_x - center_x) + offset * math.cos(perp_angle_rad)
                    if min_y <= y_at_left <= max_y:
                        intersections.append((min_x, y_at_left))
                    y_at_right = center_y + tan_angle * (max_x - center_x) + offset * math.cos(perp_angle_rad)
                    if min_y <= y_at_right <= max_y:
                        intersections.append((max_x, y_at_right))
                else:
                    x_line = center_x + offset * math.cos(perp_angle_rad)
                    if min_x <= x_line <= max_x:
                        intersections = [(x_line, min_y), (x_line, max_y)]
                
                if len(intersections) >= 2:
                    if len(intersections) > 2:
                        max_dist = 0
                        best_pair = (intersections[0], intersections[1])
                        for i1, p1 in enumerate(intersections):
                            for i2, p2 in enumerate(intersections[i1+1:], i1+1):
                                dist = math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
                                if dist > max_dist:
                                    max_dist = dist
                                    best_pair = (p1, p2)
                        intersections = list(best_pair)
                    
                    p1, p2 = intersections[0], intersections[1]
                    contour_intersections = self._line_contour_intersections(contour, p1[0], p1[1], p2[0], p2[1])
                    
                    if len(contour_intersections) >= 2:
                        def dist_from_p1(p):
                            return math.sqrt((p[0] - p1[0])**2 + (p[1] - p1[1])**2)
                        contour_intersections.sort(key=dist_from_p1)
                        
                        for j in range(0, len(contour_intersections) - 1, 2):
                            if j + 1 < len(contour_intersections):
                                x1, y1 = contour_intersections[j]
                                x2, y2 = contour_intersections[j + 1]
                                lines.append(f'G1 X{x1:.3f} Y{y1:.3f} F{speed:.0f} ; Infill move')
                                self.current_x, self.current_y = x1, y1
                                e_amount = self._calculate_extrusion(x1, y1, x2, y2, extrusion_width)
                                self.current_e += e_amount
                                lines.append(f'G1 X{x2:.3f} Y{y2:.3f} E{self.current_e:.5f} F{speed:.0f} ; Infill')
                                self.current_x, self.current_y = x2, y2
        
        return lines
    
    def _generate_honeycomb_infill(self, contour: List[Tuple[float, float]],
                                  min_x: float, max_x: float, min_y: float, max_y: float,
                                  spacing: float, speed: float, extrusion_width: float, layer_num: int = 0) -> List[str]:
        """
        Generate honeycomb infill pattern (simplified approximation)
        Uses three directions: 0°, 60°, 120° (similar to triangles but with different spacing)
        """
        lines = []
        
        # Honeycomb uses three directions with 60° spacing
        angles = [0, 60, 120]
        
        for angle_deg in angles:
            angle_rad = math.radians(angle_deg)
            tan_angle = math.tan(angle_rad) if abs(math.cos(angle_rad)) > 0.001 else float('inf')
            
            center_x = (min_x + max_x) / 2
            center_y = (min_y + max_y) / 2
            diag_length = math.sqrt((max_x - min_x)**2 + (max_y - min_y)**2)
            perp_spacing = spacing / abs(math.cos(angle_rad)) if abs(math.cos(angle_rad)) > 0.001 else spacing / abs(math.sin(angle_rad))
            num_lines = int(diag_length / perp_spacing) + 2
            
            for i in range(-num_lines, num_lines + 1):
                offset = i * perp_spacing
                perp_angle = angle_deg + 90
                perp_angle_rad = math.radians(perp_angle)
                
                intersections = []
                if abs(tan_angle) < 1000:
                    x_at_top = center_x + (max_y - center_y - offset * math.cos(perp_angle_rad)) / tan_angle
                    if min_x <= x_at_top <= max_x:
                        intersections.append((x_at_top, max_y))
                    x_at_bottom = center_x + (min_y - center_y - offset * math.cos(perp_angle_rad)) / tan_angle
                    if min_x <= x_at_bottom <= max_x:
                        intersections.append((x_at_bottom, min_y))
                    y_at_left = center_y + tan_angle * (min_x - center_x) + offset * math.cos(perp_angle_rad)
                    if min_y <= y_at_left <= max_y:
                        intersections.append((min_x, y_at_left))
                    y_at_right = center_y + tan_angle * (max_x - center_x) + offset * math.cos(perp_angle_rad)
                    if min_y <= y_at_right <= max_y:
                        intersections.append((max_x, y_at_right))
                else:
                    x_line = center_x + offset * math.cos(perp_angle_rad)
                    if min_x <= x_line <= max_x:
                        intersections = [(x_line, min_y), (x_line, max_y)]
                
                if len(intersections) >= 2:
                    if len(intersections) > 2:
                        max_dist = 0
                        best_pair = (intersections[0], intersections[1])
                        for i1, p1 in enumerate(intersections):
                            for i2, p2 in enumerate(intersections[i1+1:], i1+1):
                                dist = math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
                                if dist > max_dist:
                                    max_dist = dist
                                    best_pair = (p1, p2)
                        intersections = list(best_pair)
                    
                    p1, p2 = intersections[0], intersections[1]
                    contour_intersections = self._line_contour_intersections(contour, p1[0], p1[1], p2[0], p2[1])
                    
                    if len(contour_intersections) >= 2:
                        def dist_from_p1(p):
                            return math.sqrt((p[0] - p1[0])**2 + (p[1] - p1[1])**2)
                        contour_intersections.sort(key=dist_from_p1)
                        
                        for j in range(0, len(contour_intersections) - 1, 2):
                            if j + 1 < len(contour_intersections):
                                x1, y1 = contour_intersections[j]
                                x2, y2 = contour_intersections[j + 1]
                                lines.append(f'G1 X{x1:.3f} Y{y1:.3f} F{speed:.0f} ; Infill move')
                                self.current_x, self.current_y = x1, y1
                                e_amount = self._calculate_extrusion(x1, y1, x2, y2, extrusion_width)
                                self.current_e += e_amount
                                lines.append(f'G1 X{x2:.3f} Y{y2:.3f} E{self.current_e:.5f} F{speed:.0f} ; Infill')
                                self.current_x, self.current_y = x2, y2
        
        return lines
    
    def _line_contour_intersections(self, contour: List[Tuple[float, float]], 
                                    x1: float, y1: float, x2: float, y2: float) -> List[Tuple[float, float]]:
        """Find intersections between a line segment and a contour"""
        intersections = []
        
        for i in range(len(contour)):
            p1 = contour[i]
            p2 = contour[(i + 1) % len(contour)]
            
            # Check if line segments intersect
            intersect = self._line_segment_intersection((x1, y1), (x2, y2), p1, p2)
            if intersect:
                intersections.append(intersect)
        
        return intersections
    
    def _line_segment_intersection(self, p1: Tuple[float, float], p2: Tuple[float, float],
                                   p3: Tuple[float, float], p4: Tuple[float, float]):
        """Find intersection point of two line segments"""
        x1, y1 = p1
        x2, y2 = p2
        x3, y3 = p3
        x4, y4 = p4
        
        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
        if abs(denom) < 1e-10:
            return None
        
        t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom
        u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom
        
        if 0 <= t <= 1 and 0 <= u <= 1:
            x = x1 + t * (x2 - x1)
            y = y1 + t * (y2 - y1)
            return (x, y)
        
        return None
    
    def _point_in_contour(self, point: Tuple[float, float], contour: List[Tuple[float, float]]) -> bool:
        """Check if a point is inside a contour using ray casting algorithm"""
        x, y = point
        inside = False
        
        for i in range(len(contour)):
            xi, yi = contour[i]
            xj, yj = contour[(i + 1) % len(contour)]
            
            if ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi):
                inside = not inside
        
        return inside
    
    def _calculate_extrusion(self, x1: float, y1: float, x2: float, y2: float, extrusion_width: float = None) -> float:
        """Calculate extrusion amount for a move"""
        if extrusion_width is None:
            extrusion_width = self.extrusion_width
        
        distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        if distance < 0.001:  # Very small moves, no extrusion
            return 0.0
        
        # Calculate volume of filament needed
        volume = distance * extrusion_width * self.layer_height
        
        # Convert to filament length
        filament_area = math.pi * (self.filament_diameter / 2)**2
        filament_length = volume / filament_area
        
        return filament_length
    
    def _generate_footer(self) -> List[str]:
        """Generate G-code footer"""
        lines = [
            '; End of print',
            'M104 S0 ; Turn off extruder',
            'M140 S0 ; Turn off bed',
            'G91 ; Relative positioning',
            'G1 E-2 F2700 ; Retract filament',
            'G1 Z10 F3000 ; Raise Z',
            'G90 ; Absolute positioning',
            'G1 X0 Y220 F3000 ; Move to front',
            'M84 ; Disable steppers',
            'M107 ; Turn off fan',
        ]
        return lines
